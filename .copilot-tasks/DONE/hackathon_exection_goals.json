{
  "hackathon_execution_goals": [
    {
      "id": "overall_hackathon_mode",
      "title": "Hackathon Mode â€“ Ship an End-to-End Demo Tonight",
      "copilot_prompt": "You are helping finalize an MVP of Crew-7 for a hackathon. The goal: by tonight we must have a working end-to-end demo using ONE example full-stack crew that:\n\n1) Lets a user select the \"Full-Stack SaaS Crew\" and describe a mission (e.g. \"Build a simple SaaS landing + API\").\n2) Runs a 7-agent CrewAI crew (1 Orchestrator, 6 Specialists) with real tools.\n3) Uses Gemini as the Orchestrator model and different aimalapi models for each specialist.\n4) Uses Qdrant for long-term memory (per crew + per mission).\n5) Streams live events into the Agent Graph (Advanced Mode) and the chat.\n6) Shows generated code in a code canvas and, when possible, a live preview (for web outputs).\n\nWhen changing code, prefer minimal, targeted edits. Do NOT refactor everything. We only care about shipping a clean, stable demo for this hackathon.\n\nIMPORTANT: Do not remove or break any existing features or flows. If something is already more advanced than described here, KEEP it and integrate these changes around it instead of downgrading."
    },
    {
      "id": "backend_models_and_crewai_wiring",
      "title": "Wire Gemini, aimalapi Models, and CrewAI",
      "copilot_prompt": "Backend task: finalize model + CrewAI integration.\n\nGoals:\n1) Use CrewAI as the orchestration framework for the 7-agent crew.\n2) Orchestrator model: Gemini (via Google AI / generative language API). Configure via env vars (GEMINI_API_KEY, GEMINI_MODEL_NAME). Do NOT hardcode keys.\n3) Specialist models: use aimalapi for each specialist with possibly different models per role. Example env vars:\n   - AIMAL_BACKEND_MODEL\n   - AIMAL_FRONTEND_MODEL\n   - AIMAL_QA_MODEL\n   - AIMAL_DEVOPS_MODEL\n4) Create a central 'models.py' or equivalent where you:\n   - Define a helper to get the Gemini LLM client.\n   - Define helpers to get each aimalapi LLM client.\n5) In the CrewAI crew definition, assign:\n   - Orchestrator -> Gemini model\n   - Specialists -> appropriate aimalapi models (backend, frontend, QA, DevOps, etc.).\n6) Make sure retries, temperature, and max_tokens are reasonable for hackathon (fast and cheap).\n7) If Crew Studio integration is available, reuse any existing patterns but DO NOT get stuck on it; prioritize a plain CrewAI crew that runs reliably.\n\nAt the end, we must be able to start a crew run from the backend and see model calls go to Gemini for orchestration and aimalapi for specialists.\n\nIMPORTANT: Preserve any existing model wiring that already works. If you find more advanced routing or configuration, adapt it to include Gemini + aimalapi instead of simplifying it."
    },
    {
      "id": "backend_fullstack_crew_definition",
      "title": "Define the Full-Stack SaaS Crew (7 Agents)",
      "copilot_prompt": "Backend task: define one concrete 7-agent crew called 'Full-Stack SaaS Crew'. This will be our main demo crew.\n\nCrew structure (use CrewAI agents):\n1) Orchestrator (model: Gemini)\n   - Role: 'Orchestrator / Tech Lead'\n   - Goal: Take the user mission, break it into tasks, assign to specialists, coordinate progress, and ensure a coherent final deliverable.\n   - Description: Responsible for planning, architecture decisions, sequencing tasks between backend, frontend, QA, and DevOps, and using memory (Qdrant) to maintain context across iterations.\n   - Tools: memory read/write, tasks routing, summary generation.\n\n2) Backend Architect (aimalapi)\n   - Goal: Design the backend architecture (APIs, data models, auth strategy) for a simple SaaS application.\n   - Tools: code generation, schema design, markdown diagrams.\n\n3) Backend Implementer (aimalapi)\n   - Goal: Implement FastAPI (or current backend stack) endpoints, DB models, and basic business logic according to the architect's design.\n   - Tools: file writer tool, test scaffold generator.\n\n4) Frontend Architect (aimalapi)\n   - Goal: Design the UI structure, pages, navigation, and state flows (e.g. React/Next.js or current frontend stack) for the SaaS app.\n   - Tools: component tree sketches, routing mapping, UX notes.\n\n5) Frontend Implementer (aimalapi)\n   - Goal: Implement pages/components, API calls, and basic layout following the architect's plan and the design language of Crew-7.\n   - Tools: file writer tool, CSS/Tailwind code generator.\n\n6) QA / Test Engineer (aimalapi)\n   - Goal: Generate unit tests, integration tests, and basic test plans for backend and frontend. Highlight potential edge cases.\n   - Tools: test file generator, checklist generator.\n\n7) DevOps / Infra Engineer (aimalapi)\n   - Goal: Propose and generate minimal CI script, Dockerfile(s), and instructions for local dev + deployment.\n   - Tools: Dockerfile writer, CI YAML generator.\n\nUse CrewAI's hierarchical or hybrid process, with the Orchestrator managing the mission. Add brief instructions to each agent so the models stay focused. Expose this crew via an API endpoint like POST /api/crews/fullstack/run.\n\nIMPORTANT: Do not remove or regress any existing crew definitions. If a more advanced crew or config mechanism is already in place, add this Full-Stack SaaS Crew alongside it, using the existing patterns."
    },
    {
      "id": "backend_workflow_events_and_graph",
      "title": "Stream Workflow Events for Agent Graph",
      "copilot_prompt": "Backend task: ensure workflow events are emitted for the Agent Graph.\n\nRequirements:\n1) For each crew run, emit events whenever:\n   - Orchestrator starts/finishes a planning step.\n   - A specialist starts/finishes a task.\n   - A tool is called or returns a result.\n2) Event fields should include at minimum:\n   - mission_id, crew_id, agent_id, agent_role\n   - event_type (agent_start, agent_end, tool_call, tool_result, message, error)\n   - timestamp\n   - short description or content summary\n3) Stream these events over WebSocket or SSE to the frontend endpoint already reserved for the graph (e.g. /ws/graph or similar).\n4) Make sure events for the Full-Stack SaaS Crew are rich enough to animate the graph (node highlight, edge messages).\n5) Log events to DB or in-memory store so the run can be replayed or inspected later.\n\nDo not break existing endpoints. If needed, add a 'v2' event payload while keeping older clients working.\n\nIMPORTANT: If an event bus or streaming mechanism already exists and is more advanced (Redis, NATS, etc.), extend it instead of replacing it. The goal is additive improvements, not rewrites."
    },
    {
      "id": "frontend_agent_graph_and_chat",
      "title": "Frontend: Agent Graph + Chat Integration for Full-Stack Crew",
      "copilot_prompt": "Frontend task: wire the existing chat + Advanced Mode (Agent Graph) to the new backend events and Full-Stack SaaS Crew.\n\nGoals:\n1) In Chat Mode:\n   - User selects the 'Full-Stack SaaS Crew' from a crew selector.\n   - User types a mission (e.g. 'Build a simple SaaS for subscriptions').\n   - Chat shows streaming responses from the Orchestrator and key agent summaries.\n2) In Advanced Mode:\n   - Show the 7 nodes (Orchestrator + 6 specialists) on the XYFlow/ReactFlow graph.\n   - Use the WebSocket/SSE events to:\n     - Highlight the active node.\n     - Animate edges when messages or tool calls happen.\n     - Show small tooltips/logs when hovering a node.\n   - Ensure the graph does not break or slow down the chat.\n3) Graph layout can be static for now (e.g. Orchestrator at top, specialists around), but must look clean and readable.\n4) Make sure the UI reflects run status (idle, running, failed, completed).\n\nKeep styling in line with the current dark, neon, blueprint aesthetic. Avoid major redesigns, just integrate the graph behavior.\n\nIMPORTANT: Do not remove any existing chat features, shortcuts, or layout behaviors that already work. If the current graph implementation is more advanced, plug the new data into it instead of simplifying it."
    },
    {
      "id": "frontend_code_canvas_and_preview",
      "title": "Code Canvas + Live Preview",
      "copilot_prompt": "Frontend task: add a \"Code Canvas\" section where users can inspect artifacts generated by the Full-Stack SaaS Crew.\n\nRequirements:\n1) Add a panel or page (e.g. 'Artifacts' tab or split pane under chat) that shows:\n   - A file tree (list of generated files: backend, frontend, tests, Dockerfile, etc.).\n   - A code viewer/editor (read-only is fine for now) that displays the selected file with syntax highlighting.\n2) For previewable outputs (e.g. static HTML, or a built-in small React preview):\n   - Add a simple live preview pane that renders basic HTML/JS/CSS output.\n   - It's okay if this is limited (e.g. an iframe or sandboxed React component).\n3) Connect this to the backend artifacts API (or create a simple endpoint) so that after a run, we can request the generated files.\n4) Keep the layout aligned with the blueprint/robot aesthetic: dark background, subtle grid, minimal but clear framing.\n\nThe goal is that during the demo, we can:\n- Run the crew.\n- Show the Agent Graph.\n- Then open the Code Canvas and scroll through real generated code + a small UI preview.\n\nIMPORTANT: If a basic artifact viewer already exists, extend it instead of replacing it. Preserve all current functionality and add the preview / tree behavior on top."
    },
    {
      "id": "frontend_qdrant_memory_feedback",
      "title": "Visual Hint That Memory Is Active",
      "copilot_prompt": "Frontend task: add small UI hints that the crew is using memory (Qdrant) without exposing any secrets.\n\nIdeas:\n1) In the chat, when the Orchestrator pulls from memory, show a subtle tag like 'memory recall' next to the message.\n2) In Advanced Mode, show a small badge on the Orchestrator node (e.g. 'MEM' or a glowing ring) when memory read/write happens.\n3) Add a non-interactive 'Memory' info box for the demo that explains: 'This crew stores mission context in Qdrant so it can remember architecture decisions, API contracts, and previous attempts.'\n\nDo NOT expose raw vectors or sensitive content. Keep this visual and high-level, just for the judges to understand that memory is really there.\n\nIMPORTANT: Do not remove or alter any existing status indicators that users may already rely on. Layer these hints in a subtle, additive way."
    }
  ]
}
